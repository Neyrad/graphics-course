#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant) uniform Params
{
  // vec2 iResolution;
  float iResolution_x;
  float iResolution_y;
  // vec2 iMouse;
  float iMouse_x;
  float iMouse_y;
  float iTime;
} params;

const vec3  eye      = vec3(0, 2, 10);
const vec3  light    = vec3(0, 6, 5);
const int   maxSteps = 70;
const float eps      = 0.01;
const float maxDist = 300.0;
const float fov = 0.5;

mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

float sdThickDisk( in vec3 p, in vec3 n, in float r, in float thick, in vec3 pos )
{
    vec3 d = dot(p - pos, n) * n;
    vec3 o = (p - pos) - d;
    o -= normalize( o ) * min( length( o ), r );
    return length( d + o ) - thick;
}

float dSphere(vec3 p, float r, vec3 pos) {
    return length(p - pos) - r;
}

float opSubtraction( float d1, float d2 )
{
    return max(-d1,d2);
}

float dRing(in vec3 q, float inR, float outR, in vec3 pos)
{
    float disk = sdThickDisk(q, vec3(0.0, 1.0, 0.0), outR, 0.01, pos);
    float ring = opSubtraction(dSphere(q - vec3(0.0, 0.0, 0.0), inR, pos), disk);
    return ring;
}

const float INF = 1e9;
vec3 dRings(in vec3 q, int n, float dist, float shift, in vec3 pos, float id)
{
    float step = dist * (1.0 / float(n));
    float ret = INF;
    float curRing = 0.0;
    for (int i = 0; i < n; ++i)
    {
        float inR  = shift + step * float(i);
        float outR = shift + step * (float(i) + 0.5);
        float ring = dRing(q, inR, outR, pos);
        if (ring < ret)
        {
            ret = ring;
            curRing = float(i);
        }

    }
    return vec3(ret, curRing, id);
}

vec3 saturnSdf(in vec3 p, in vec2 uv, in mat3 m, in vec4 pos, float id)
{
    vec3 q = m * p;

    // Ring
    vec3 pos3 = vec3(pos.x, pos.y, pos.z);
    int nRings = int(pos.w);
    vec3 ringsSdf = dRings(q, nRings, 2.0, 1.5, pos3, id);

    // Sphere
    float sphereSdf = dSphere(q, 1.1, pos.xyz);


    if (ringsSdf.x < sphereSdf)
    {
        return ringsSdf;
    }
    else return vec3(sphereSdf, 0, id);
}

vec3 sdf(in vec3 p, in vec2 uv, in mat3 m)
{
    vec4 planet[6];
    int nPlanets = 5;

    float orbitRadius = 9.0;
    float orbitSpeed = params.iTime * (1. / 5.);
    float coss = orbitRadius * cos(orbitSpeed);
    float sinn = orbitRadius * sin(orbitSpeed);
    float mcoss = coss * (1. / 5.);
    float msinn = sinn * (1. / 5.);
    planet[0] = vec4(2.*coss, 5. + mcoss, sinn, 3.);
    planet[1] = vec4(-coss, -3. + mcoss, -sinn, 1.);
    planet[2] = vec4(3.*sinn, msinn, coss, 2.);
    planet[3] = vec4(1. + coss, -5. + msinn, 2.*sinn, 2.);
    planet[4] = vec4(-2. - mcoss, -3. + mcoss, -1.5*coss, 0.);

    vec3 ret = vec3(INF, 0, 0);
    int id = 0;
    for (int i = 0; i < nPlanets; ++i)
    {
        vec3 saturn = saturnSdf(p, uv, m, planet[i], float(id));
        if (saturn.x < ret.x) ret = saturn;
        ++id;
    }
    return ret;
}

vec3 trace(in vec2 uv, in vec3 from, in vec3 dir, out bool hit, out float id, in mat3 m) {
    vec3 p = from;
    float totalDist = 0.0;
    id = -1.0;
    hit = false;

    for (int steps = 0; steps < maxSteps; steps++) {
        vec3 distAndID = sdf(p, uv, m);
        float dist = abs(distAndID.x);

        if (dist < eps) {
            hit = true;
            id = distAndID.z;
            break;
        }

        totalDist += dist;
        if (totalDist > maxDist) {
            break;
        }
        p += dist * dir;
    }
    return p;
}

vec3 generateNormal(in vec2 uv, vec3 z, float d, in mat3 m) {
    float e = max(d * 0.5, eps);
    float dx1 = sdf(z + vec3(e, 0, 0), uv, m).x;
    float dx2 = sdf(z - vec3(e, 0, 0), uv, m).x;
    float dy1 = sdf(z + vec3(0, e, 0), uv, m).x;
    float dy2 = sdf(z - vec3(0, e, 0), uv, m).x;
    float dz1 = sdf(z + vec3(0, 0, e), uv, m).x;
    float dz2 = sdf(z - vec3(0, 0, e), uv, m).x;

    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));
}

void main()
{
    vec2 iResolution = vec2(params.iResolution_x, params.iResolution_y);
    vec2 iMouse = vec2(params.iMouse_x, params.iMouse_y);
    vec2 uv = (gl_GlobalInvocationID.xy/iResolution.xy - vec2(0.5)) * 10.0 * iResolution.xy / max(iResolution.x, iResolution.y);

    bool hit;
    float id;

    vec3 mouse = vec3(iMouse.xy / iResolution.xy - 0.5, 0);
    mat3 m = rotateX(6.0 * mouse.y) * rotateY(6.0 * mouse.x);

    //vec2 scale = 9.0 * iResolution.xy / max(iResolution.x, iResolution.y);
    //vec2 uv = scale * (fragCoord / iResolution.xy - vec2(0.5));

    //vec3 dir = normalize(vec3(uv, 0) - eye);
    vec3 dir = normalize(vec3(uv * fov, -1.0));

    vec3 p = trace(uv, eye, dir, hit, id, m);

    vec3 color = vec3(0, 0, 0.06);

    vec3 l = normalize(light - p);
    vec3 v = normalize(eye - p);
    vec3 n = generateNormal(uv, p, 0.001, m);
    vec3 h = normalize(l + v);

    float nl = max(0.0, dot(n, l));
    float sp = pow(max(0.0, dot(h, n)), 150.0);

    if (hit) {

        vec3 objColor;
        switch (int(id) % 4)
        {
            case 0:
                objColor = vec3(0.851, 0.839, 0.255);
                //objColor = vec3(1., 0., 0.);
                break;
            case 1:
                objColor = vec3(0.788, 0.631, 0.263);
                //objColor = vec3(0., 1., 0.);
                break;
            case 2:
                objColor = vec3(0.757, 0.278, 0.831);
                //objColor = vec3(0., 0., 1.);
                break;
            case 3:
                objColor = vec3(0.255, 0.808, 0.851);
                //objColor = vec3(0., 0., 1.);
                break;
            default:
                objColor = vec3(0.408, 0.71, 0.416);
                //objColor = vec3(1., 1., 0.);
                break;
        }

        // Lighting model
        int lightingModel = 1;
        switch (lightingModel) {
            case 0: // Lambert
                color = objColor * nl;
                break;
            case 1: // Lambert + Phong
                color = objColor * nl + 3.5 * sp * vec3(1, 1, 1);
                break;
        }
    }

    if (uv.x < 1280 && uv.y < 720)
        imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}
